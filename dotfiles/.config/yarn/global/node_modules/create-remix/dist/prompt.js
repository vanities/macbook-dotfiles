/**
 * create-remix v2.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var process = require('node:process');
var promptsConfirm = require('./prompts-confirm.js');
var promptsSelect = require('./prompts-select.js');
var promptsMultiSelect = require('./prompts-multi-select.js');
var promptsText = require('./prompts-text.js');
var utils = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var process__default = /*#__PURE__*/_interopDefaultLegacy(process);

// Adapted from https://github.com/withastro/cli-kit
const prompts = {
  text: args => toPrompt(promptsText.TextPrompt, args),
  confirm: args => toPrompt(promptsConfirm.ConfirmPrompt, args),
  select: args => toPrompt(promptsSelect.SelectPrompt, args),
  multiselect: args => toPrompt(promptsMultiSelect.MultiSelectPrompt, args)
};
async function prompt(questions, opts = {}) {
  let {
    onSubmit = utils.identity,
    onCancel = () => process__default["default"].exit(0),
    stdin = process__default["default"].stdin,
    stdout = process__default["default"].stdout
  } = opts;
  let answers = {};
  let questionsArray = Array.isArray(questions) ? questions : [questions];
  let answer;
  let quit;
  let name;
  let type;
  for (let question of questionsArray) {
    ({
      name,
      type
    } = question);
    try {
      // Get the injected answer if there is one or prompt the user
      // @ts-expect-error
      answer = await prompts[type](Object.assign({
        stdin,
        stdout
      }, question));
      answers[name] = answer;
      quit = await onSubmit(question, answer, answers);
    } catch (err) {
      quit = !(await onCancel(question, answers));
    }
    if (quit) {
      return answers;
    }
  }
  return answers;
}
function toPrompt(el, args, opts = {}) {
  if (el !== promptsText.TextPrompt && el !== promptsConfirm.ConfirmPrompt && el !== promptsSelect.SelectPrompt && el !== promptsMultiSelect.MultiSelectPrompt) {
    throw new Error(`Invalid prompt type: ${el.name}`);
  }
  return new Promise((res, rej) => {
    let p = new el(args,
    // @ts-expect-error
    opts);
    let onAbort = args.onAbort || opts.onAbort || utils.identity;
    let onSubmit = args.onSubmit || opts.onSubmit || utils.identity;
    let onExit = args.onExit || opts.onExit || utils.identity;
    p.on("state", args.onState || utils.identity);
    p.on("submit", x => res(onSubmit(x)));
    p.on("exit", x => res(onExit(x)));
    p.on("abort", x => rej(onAbort(x)));
  });
}

exports.prompt = prompt;
