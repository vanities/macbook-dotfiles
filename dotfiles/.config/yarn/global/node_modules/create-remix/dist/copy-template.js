/**
 * create-remix v2.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var process = require('node:process');
var url = require('node:url');
var fs = require('node:fs');
var path = require('node:path');
var stream = require('node:stream');
var node_util = require('node:util');
var webFetch = require('@remix-run/web-fetch');
var gunzip = require('gunzip-maybe');
var tar = require('tar-fs');
var proxyAgent = require('proxy-agent');
var utils = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var process__default = /*#__PURE__*/_interopDefaultLegacy(process);
var url__default = /*#__PURE__*/_interopDefaultLegacy(url);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
var gunzip__default = /*#__PURE__*/_interopDefaultLegacy(gunzip);
var tar__default = /*#__PURE__*/_interopDefaultLegacy(tar);

const defaultAgent = new proxyAgent.ProxyAgent();
const httpsAgent = new proxyAgent.ProxyAgent();
httpsAgent.protocol = "https:";
function agent(url) {
  return new URL(url).protocol === "https:" ? httpsAgent : defaultAgent;
}
async function copyTemplate(template, destPath, options) {
  let {
    log = () => {}
  } = options;

  /**
   * Valid templates are:
   * - local file or directory on disk
   * - GitHub owner/repo shorthand
   * - GitHub owner/repo/directory shorthand
   * - full GitHub repo URL
   * - any tarball URL
   */

  try {
    if (isLocalFilePath(template)) {
      log(`Using the template from local file at "${template}"`);
      let filepath = template.startsWith("file://") ? url__default["default"].fileURLToPath(template) : template;
      let isLocalDir = await copyTemplateFromLocalFilePath(filepath, destPath);
      return isLocalDir ? {
        localTemplateDirectory: filepath
      } : undefined;
    }
    if (isGithubRepoShorthand(template)) {
      log(`Using the template from the "${template}" repo`);
      await copyTemplateFromGithubRepoShorthand(template, destPath, options);
      return;
    }
    if (isValidGithubRepoUrl(template)) {
      log(`Using the template from "${template}"`);
      await copyTemplateFromGithubRepoUrl(template, destPath, options);
      return;
    }
    if (utils.isUrl(template)) {
      log(`Using the template from "${template}"`);
      await copyTemplateFromGenericUrl(template, destPath, options);
      return;
    }
    throw new CopyTemplateError(`"${utils.color.bold(template)}" is an invalid template. Run ${utils.color.bold("create-remix --help")} to see supported template formats.`);
  } catch (error) {
    await options.onError(error);
  }
}
function isLocalFilePath(input) {
  try {
    return input.startsWith("file://") || fs__default["default"].existsSync(path__default["default"].isAbsolute(input) ? input : path__default["default"].resolve(process__default["default"].cwd(), input));
  } catch (_) {
    return false;
  }
}
async function copyTemplateFromRemoteTarball(url, destPath, options) {
  return await downloadAndExtractTarball(destPath, url, options);
}
async function copyTemplateFromGithubRepoShorthand(repoShorthand, destPath, options) {
  let [owner, name, ...path] = repoShorthand.split("/");
  let filePath = path.length ? path.join("/") : null;
  await downloadAndExtractRepoTarball({
    owner,
    name,
    filePath
  }, destPath, options);
}
async function copyTemplateFromGithubRepoUrl(repoUrl, destPath, options) {
  await downloadAndExtractRepoTarball(getRepoInfo(repoUrl), destPath, options);
}
async function copyTemplateFromGenericUrl(url, destPath, options) {
  await copyTemplateFromRemoteTarball(url, destPath, options);
}
async function copyTemplateFromLocalFilePath(filePath, destPath) {
  if (filePath.endsWith(".tar.gz") || filePath.endsWith(".tgz")) {
    await extractLocalTarball(filePath, destPath);
    return false;
  }
  if (fs__default["default"].statSync(filePath).isDirectory()) {
    // If our template is just a directory on disk, return true here, and we'll
    // just copy directly from there instead of "extracting" to a temp
    // directory first
    return true;
  }
  throw new CopyTemplateError("The provided template is not a valid local directory or tarball.");
}
const pipeline = node_util.promisify(stream__default["default"].pipeline);
async function extractLocalTarball(tarballPath, destPath) {
  try {
    await pipeline(fs__default["default"].createReadStream(tarballPath), gunzip__default["default"](), tar__default["default"].extract(destPath, {
      strip: 1
    }));
  } catch (error) {
    throw new CopyTemplateError("There was a problem extracting the file from the provided template." + `  Template filepath: \`${tarballPath}\`` + `  Destination directory: \`${destPath}\`` + `  ${error}`);
  }
}
async function downloadAndExtractRepoTarball(repo, destPath, options) {
  // If we have a direct file path we will also have the branch. We can skip the
  // redirect and get the tarball URL directly.
  if (repo.branch && repo.filePath) {
    let tarballURL = `https://codeload.github.com/${repo.owner}/${repo.name}/tar.gz/${repo.branch}`;
    return await downloadAndExtractTarball(destPath, tarballURL, {
      ...options,
      filePath: repo.filePath
    });
  }

  // If we don't know the branch, the GitHub API will figure out the default and
  // redirect the request to the tarball.
  // https://docs.github.com/en/rest/reference/repos#download-a-repository-archive-tar
  let url = `https://api.github.com/repos/${repo.owner}/${repo.name}/tarball`;
  if (repo.branch) {
    url += `/${repo.branch}`;
  }
  return await downloadAndExtractTarball(destPath, url, {
    ...options,
    filePath: repo.filePath ?? null
  });
}
async function downloadAndExtractTarball(downloadPath, tarballUrl, {
  token,
  filePath
}) {
  let resourceUrl = tarballUrl;
  let headers = {};
  let isGithubUrl = new URL(tarballUrl).host.endsWith("github.com");
  if (token && isGithubUrl) {
    headers.Authorization = `token ${token}`;
  }
  if (isGithubReleaseAssetUrl(tarballUrl)) {
    var _body$assets$find;
    // We can download the asset via the GitHub api, but first we need to look
    // up the asset id
    let info = getGithubReleaseAssetInfo(tarballUrl);
    headers.Accept = "application/vnd.github.v3+json";
    let releaseUrl = info.tag === "latest" ? `https://api.github.com/repos/${info.owner}/${info.name}/releases/latest` : `https://api.github.com/repos/${info.owner}/${info.name}/releases/tags/${info.tag}`;
    let response = await webFetch.fetch(releaseUrl, {
      agent: agent("https://api.github.com"),
      headers
    });
    if (response.status !== 200) {
      throw new CopyTemplateError("There was a problem fetching the file from GitHub. The request " + `responded with a ${response.status} status. Please try again later.`);
    }
    let body = await response.json();
    if (!body || typeof body !== "object" || !body.assets || !Array.isArray(body.assets)) {
      throw new CopyTemplateError("There was a problem fetching the file from GitHub. No asset was " + "found at that url. Please try again later.");
    }
    let assetId = (_body$assets$find = body.assets.find(asset => {
      var _asset$browser_downlo;
      // If the release is "latest", the url won't match the download url
      return info.tag === "latest" ? asset === null || asset === void 0 ? void 0 : (_asset$browser_downlo = asset.browser_download_url) === null || _asset$browser_downlo === void 0 ? void 0 : _asset$browser_downlo.includes(info.asset) : (asset === null || asset === void 0 ? void 0 : asset.browser_download_url) === tarballUrl;
    })) === null || _body$assets$find === void 0 ? void 0 : _body$assets$find.id;
    if (assetId == null) {
      throw new CopyTemplateError("There was a problem fetching the file from GitHub. No asset was " + "found at that url. Please try again later.");
    }
    resourceUrl = `https://api.github.com/repos/${info.owner}/${info.name}/releases/assets/${assetId}`;
    headers.Accept = "application/octet-stream";
  }
  let response = await webFetch.fetch(resourceUrl, {
    agent: agent(resourceUrl),
    headers
  });
  if (!response.body || response.status !== 200) {
    if (token) {
      throw new CopyTemplateError(`There was a problem fetching the file${isGithubUrl ? " from GitHub" : ""}. The request ` + `responded with a ${response.status} status. Perhaps your \`--token\`` + "is expired or invalid.");
    }
    throw new CopyTemplateError(`There was a problem fetching the file${isGithubUrl ? " from GitHub" : ""}. The request ` + `responded with a ${response.status} status. Please try again later.`);
  }

  // file paths returned from GitHub are always unix style
  if (filePath) {
    filePath = filePath.split(path__default["default"].sep).join(path__default["default"].posix.sep);
  }
  let filePathHasFiles = false;
  try {
    let input = new stream__default["default"].PassThrough();
    // Start reading stream into passthrough, don't await to avoid buffering
    writeReadableStreamToWritable(response.body, input);
    await pipeline(input, gunzip__default["default"](), tar__default["default"].extract(downloadPath, {
      map(header) {
        let originalDirName = header.name.split("/")[0];
        header.name = header.name.replace(`${originalDirName}/`, "");
        if (filePath) {
          // Include trailing slash on startsWith when filePath doesn't include
          // it so something like `templates/remix` doesn't inadvertently
          // include `templates/remix-javascript/*` files
          if (filePath.endsWith(path__default["default"].posix.sep) && header.name.startsWith(filePath) || !filePath.endsWith(path__default["default"].posix.sep) && header.name.startsWith(filePath + path__default["default"].posix.sep)) {
            filePathHasFiles = true;
            header.name = header.name.replace(filePath, "");
          } else {
            header.name = "__IGNORE__";
          }
        }
        return header;
      },
      ignore(_filename, header) {
        if (!header) {
          throw Error("Header is undefined");
        }
        return header.name === "__IGNORE__";
      }
    }));
  } catch (_) {
    throw new CopyTemplateError("There was a problem extracting the file from the provided template." + `  Template URL: \`${tarballUrl}\`` + `  Destination directory: \`${downloadPath}\``);
  }
  if (filePath && !filePathHasFiles) {
    throw new CopyTemplateError(`The path "${filePath}" was not found in this ${isGithubUrl ? "GitHub repo." : "tarball."}`);
  }
}

// Copied from remix-node/stream.ts
async function writeReadableStreamToWritable(stream, writable) {
  let reader = stream.getReader();
  let flushable = writable;
  try {
    while (true) {
      let {
        done,
        value
      } = await reader.read();
      if (done) {
        writable.end();
        break;
      }
      writable.write(value);
      if (typeof flushable.flush === "function") {
        flushable.flush();
      }
    }
  } catch (error) {
    writable.destroy(error);
    throw error;
  }
}
function isValidGithubRepoUrl(input) {
  if (!utils.isUrl(input)) {
    return false;
  }
  try {
    let url = new URL(input);
    let pathSegments = url.pathname.slice(1).split("/");
    return url.protocol === "https:" && url.hostname === "github.com" &&
    // The pathname must have at least 2 segments. If it has more than 2, the
    // third must be "tree" and it must have at least 4 segments.
    // https://github.com/:owner/:repo
    // https://github.com/:owner/:repo/tree/:ref
    pathSegments.length >= 2 && (pathSegments.length > 2 ? pathSegments[2] === "tree" && pathSegments.length >= 4 : true);
  } catch (_) {
    return false;
  }
}
function isGithubRepoShorthand(value) {
  if (utils.isUrl(value)) {
    return false;
  }
  // This supports :owner/:repo and :owner/:repo/nested/path, e.g.
  // remix-run/remix
  // remix-run/remix/templates/express
  // remix-run/examples/socket.io
  return /^[\w-]+\/[\w-.]+(\/[\w-.]+)*$/.test(value);
}
function isGithubReleaseAssetUrl(url) {
  /**
   * Accounts for the following formats:
   * https://github.com/owner/repository/releases/download/v0.0.1/stack.tar.gz
   * ~or~
   * https://github.com/owner/repository/releases/latest/download/stack.tar.gz
   */
  return url.startsWith("https://github.com") && (url.includes("/releases/download/") || url.includes("/releases/latest/download/"));
}
function getGithubReleaseAssetInfo(browserUrl) {
  /**
   * https://github.com/owner/repository/releases/download/v0.0.1/stack.tar.gz
   * ~or~
   * https://github.com/owner/repository/releases/latest/download/stack.tar.gz
   */

  let url = new URL(browserUrl);
  let [, owner, name,, downloadOrLatest, tag, asset] = url.pathname.split("/");
  if (downloadOrLatest === "latest" && tag === "download") {
    // handle the GitHub URL quirk for latest releases
    tag = "latest";
  }
  return {
    browserUrl,
    owner,
    name,
    asset,
    tag
  };
}
function getRepoInfo(validatedGithubUrl) {
  let url = new URL(validatedGithubUrl);
  let [, owner, name, tree, branch, ...file] = url.pathname.split("/");
  let filePath = file.join("/");
  if (tree === undefined) {
    return {
      owner,
      name,
      branch: null,
      filePath: null
    };
  }
  return {
    owner,
    name,
    // If we've validated the GitHub URL and there is a tree, there will also be
    // a branch
    branch: branch,
    filePath: filePath === "" || filePath === "/" ? null : filePath
  };
}
class CopyTemplateError extends Error {
  constructor(message) {
    super(message);
    this.name = "CopyTemplateError";
  }
}

// https://docs.github.com/en/rest/releases/assets?apiVersion=2022-11-28#get-a-release-asset

exports.CopyTemplateError = CopyTemplateError;
exports.copyTemplate = copyTemplate;
