/**
 * create-remix v2.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var process = require('node:process');
var fs = require('node:fs');
var os = require('node:os');
var path = require('node:path');
var fse = require('fs-extra');
var stripAnsi = require('strip-ansi');
var rm = require('rimraf');
var execa = require('execa');
var arg = require('arg');
var semver = require('semver');
var sortPackageJSON = require('sort-package-json');
var _package = require('./package.json.js');
var prompt = require('./prompt.js');
var utils = require('./utils.js');
var loadingIndicator$1 = require('./loading-indicator.js');
var copyTemplate = require('./copy-template.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var process__default = /*#__PURE__*/_interopDefaultLegacy(process);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fse__default = /*#__PURE__*/_interopDefaultLegacy(fse);
var stripAnsi__default = /*#__PURE__*/_interopDefaultLegacy(stripAnsi);
var rm__default = /*#__PURE__*/_interopDefaultLegacy(rm);
var execa__default = /*#__PURE__*/_interopDefaultLegacy(execa);
var arg__default = /*#__PURE__*/_interopDefaultLegacy(arg);
var semver__namespace = /*#__PURE__*/_interopNamespace(semver);
var sortPackageJSON__default = /*#__PURE__*/_interopDefaultLegacy(sortPackageJSON);

async function createRemix(argv) {
  let ctx = await getContext(argv);
  if (ctx.help) {
    printHelp();
    return;
  }
  if (ctx.versionRequested) {
    utils.log(_package.version);
    return;
  }
  let steps = [introStep, projectNameStep, copyTemplateToTempDirStep, copyTempDirToAppDirStep, gitInitQuestionStep, installDependenciesQuestionStep, runInitScriptQuestionStep, installDependenciesStep, gitInitStep, runInitScriptStep, doneStep];
  try {
    for (let step of steps) {
      await step(ctx);
    }
  } catch (err) {
    if (ctx.debug) {
      console.error(err);
    }
    throw err;
  }
}
async function getContext(argv) {
  let flags = arg__default["default"]({
    "--debug": Boolean,
    "--remix-version": String,
    "-v": "--remix-version",
    "--template": String,
    "--token": String,
    "--yes": Boolean,
    "-y": "--yes",
    "--install": Boolean,
    "--no-install": Boolean,
    "--package-manager": String,
    "--show-install-output": Boolean,
    "--init-script": Boolean,
    "--no-init-script": Boolean,
    "--git-init": Boolean,
    "--no-git-init": Boolean,
    "--help": Boolean,
    "-h": "--help",
    "--version": Boolean,
    "--V": "--version",
    "--no-color": Boolean,
    "--no-motion": Boolean,
    "--overwrite": Boolean
  }, {
    argv,
    permissive: true
  });
  let {
    "--debug": debug = false,
    "--help": help = false,
    "--remix-version": selectedRemixVersion,
    "--template": template,
    "--token": token,
    "--install": install,
    "--no-install": noInstall,
    "--package-manager": pkgManager,
    "--show-install-output": showInstallOutput = false,
    "--git-init": git,
    "--no-init-script": noInitScript,
    "--init-script": initScript,
    "--no-git-init": noGit,
    "--no-motion": noMotion,
    "--yes": yes,
    "--version": versionRequested,
    "--overwrite": overwrite
  } = flags;
  let cwd = flags["_"][0];
  let interactive = utils.isInteractive();
  let projectName = cwd;
  if (!interactive) {
    yes = true;
  }
  if (selectedRemixVersion) {
    if (semver__namespace.valid(selectedRemixVersion)) ; else if (semver__namespace.coerce(selectedRemixVersion)) {
      selectedRemixVersion = semver__namespace.coerce(selectedRemixVersion).version;
    } else {
      utils.log(`\n${utils.color.warning(`${selectedRemixVersion} is an invalid version specifier. Using Remix v${_package.version}.`)}`);
      selectedRemixVersion = undefined;
    }
  }
  let context = {
    tempDir: path__default["default"].join(await fs__default["default"].promises.realpath(os__default["default"].tmpdir()), `create-remix--${Math.random().toString(36).substr(2, 8)}`),
    cwd,
    overwrite,
    interactive,
    debug,
    git: git ?? (noGit ? false : yes),
    initScript: initScript ?? (noInitScript ? false : yes),
    initScriptPath: null,
    help,
    install: install ?? (noInstall ? false : yes),
    showInstallOutput,
    noMotion,
    pkgManager: validatePackageManager(pkgManager ??
    // npm, pnpm, Yarn, and Bun set the user agent environment variable that can be used
    // to determine which package manager ran the command.
    (process__default["default"].env.npm_config_user_agent ?? "npm").split("/")[0]),
    projectName,
    prompt: prompt.prompt,
    remixVersion: selectedRemixVersion || _package.version,
    template,
    token,
    versionRequested
  };
  return context;
}
async function introStep(ctx) {
  utils.log(`\n${utils.color.bgWhite(` ${utils.color.black("remix")} `)}  ${utils.color.green(utils.color.bold(`v${ctx.remixVersion}`))} ${utils.color.bold("ðŸ’¿ Let's build a better website...")}`);
  if (!ctx.interactive) {
    utils.log("");
    utils.info("Shell is not interactive.", [`Using default options. This is equivalent to running with the `, utils.color.reset("--yes"), ` flag.`]);
  }
}
async function projectNameStep(ctx) {
  // valid cwd is required if shell isn't interactive
  if (!ctx.interactive && !ctx.cwd) {
    utils.error("Oh no!", "No project directory provided");
    throw new Error("No project directory provided");
  }
  if (ctx.cwd) {
    await utils.sleep(100);
    utils.info("Directory:", ["Using ", utils.color.reset(ctx.cwd), " as project directory"]);
  }
  if (!ctx.cwd) {
    let {
      name
    } = await ctx.prompt({
      name: "name",
      type: "text",
      label: title("dir"),
      message: "Where should we create your new project?",
      initial: "./my-remix-app"
    });
    ctx.cwd = name;
    ctx.projectName = utils.toValidProjectName(name);
    return;
  }
  let name = ctx.cwd;
  if (name === "." || name === "./") {
    let parts = process__default["default"].cwd().split(path__default["default"].sep);
    name = parts[parts.length - 1];
  } else if (name.startsWith("./") || name.startsWith("../")) {
    let parts = name.split("/");
    name = parts[parts.length - 1];
  }
  ctx.projectName = utils.toValidProjectName(name);
}
async function copyTemplateToTempDirStep(ctx) {
  if (ctx.template) {
    utils.log("");
    utils.info("Template:", ["Using ", utils.color.reset(ctx.template), "..."]);
  } else {
    utils.log("");
    utils.info("Using basic template", ["See https://remix.run/guides/templates for more"]);
  }
  let template = ctx.template ?? "https://github.com/remix-run/remix/tree/main/templates/remix";
  await loadingIndicator({
    start: "Template copying...",
    end: "Template copied",
    while: async () => {
      await utils.ensureDirectory(ctx.tempDir);
      if (ctx.debug) {
        utils.debug(`Extracting to: ${ctx.tempDir}`);
      }
      let result = await copyTemplate.copyTemplate(template, ctx.tempDir, {
        debug: ctx.debug,
        token: ctx.token,
        async onError(err) {
          utils.error("Oh no!", err instanceof copyTemplate.CopyTemplateError ? err.message : "Something went wrong. Run `create-remix --debug` to see more info.\n\n" + "Open an issue to report the problem at " + "https://github.com/remix-run/remix/issues/new");
          throw err;
        },
        async log(message) {
          if (ctx.debug) {
            utils.debug(message);
            await utils.sleep(500);
          }
        }
      });
      if (result !== null && result !== void 0 && result.localTemplateDirectory) {
        ctx.tempDir = path__default["default"].resolve(result.localTemplateDirectory);
      }
    },
    ctx
  });
}
async function copyTempDirToAppDirStep(ctx) {
  await utils.ensureDirectory(ctx.cwd);
  let files1 = await utils.getDirectoryFilesRecursive(ctx.tempDir);
  let files2 = await utils.getDirectoryFilesRecursive(ctx.cwd);
  let collisions = files1.filter(f => files2.includes(f)).sort((a, b) => a.localeCompare(b));
  if (collisions.length > 0) {
    let getFileList = prefix => {
      let moreFiles = collisions.length - 5;
      let lines = ["", ...collisions.slice(0, 5)];
      if (moreFiles > 0) {
        lines.push(`and ${moreFiles} more...`);
      }
      return lines.join(`\n${prefix}`);
    };
    if (ctx.overwrite) {
      utils.info("Overwrite:", `overwriting files due to \`--overwrite\`:${getFileList("           ")}`);
    } else if (!ctx.interactive) {
      utils.error("Oh no!", `Destination directory contains files that would be overwritten\n` + `         and no \`--overwrite\` flag was included in a non-interactive\n` + `         environment. The following files would be overwritten:` + getFileList("           "));
      throw new Error("File collisions detected in a non-interactive environment");
    } else {
      if (ctx.debug) {
        utils.debug(`Colliding files:${getFileList("          ")}`);
      }
      let {
        overwrite
      } = await ctx.prompt({
        name: "overwrite",
        type: "confirm",
        label: title("overwrite"),
        message: `Your project directory contains files that will be overwritten by\n` + `             this template (you can force with \`--overwrite\`)\n\n` + `             Files that would be overwritten:` + `${getFileList("               ")}\n\n` + `             Do you wish to continue?\n` + `             `,
        initial: false
      });
      if (!overwrite) {
        throw new Error("Exiting to avoid overwriting files");
      }
    }
  }
  await fse__default["default"].copy(ctx.tempDir, ctx.cwd, {
    filter(src, dest) {
      // We never copy .git/ or node_modules/ directories since it's highly
      // unlikely we want them copied - and because templates are primarily
      // being pulled from git tarballs which won't have .git/ and shouldn't
      // have node_modules/
      let file = utils.stripDirectoryFromPath(ctx.tempDir, src);
      let isIgnored = utils.IGNORED_TEMPLATE_DIRECTORIES.includes(file);
      if (isIgnored) {
        if (ctx.debug) {
          utils.debug(`Skipping copy of ${file} directory from template`);
        }
        return false;
      }
      return true;
    }
  });
  await updatePackageJSON(ctx);
  ctx.initScriptPath = await getInitScriptPath(ctx.cwd);
}
async function installDependenciesQuestionStep(ctx) {
  if (ctx.install === undefined) {
    let {
      deps = true
    } = await ctx.prompt({
      name: "deps",
      type: "confirm",
      label: title("deps"),
      message: `Install dependencies with ${ctx.pkgManager}?`,
      hint: "recommended",
      initial: true
    });
    ctx.install = deps;
  }
}
async function runInitScriptQuestionStep(ctx) {
  if (!ctx.initScriptPath) {
    return;
  }

  // We can't run the init script without installing dependencies
  if (!ctx.install) {
    return;
  }
  if (ctx.initScript === undefined) {
    let {
      init
    } = await ctx.prompt({
      name: "init",
      type: "confirm",
      label: title("init"),
      message: `This template has a remix.init script. Do you want to run it?`,
      hint: "recommended",
      initial: true
    });
    ctx.initScript = init;
  }
}
async function installDependenciesStep(ctx) {
  let {
    install,
    pkgManager,
    showInstallOutput,
    cwd
  } = ctx;
  if (!install) {
    await utils.sleep(100);
    utils.info("Skipping install step.", ["Remember to install dependencies after setup with ", utils.color.reset(`${pkgManager} install`), "."]);
    return;
  }
  function runInstall() {
    return installDependencies({
      cwd,
      pkgManager,
      showInstallOutput
    });
  }
  if (showInstallOutput) {
    utils.log("");
    utils.info(`Install`, `Dependencies installing with ${pkgManager}...`);
    utils.log("");
    await runInstall();
    utils.log("");
    return;
  }
  utils.log("");
  await loadingIndicator({
    start: `Dependencies installing with ${pkgManager}...`,
    end: "Dependencies installed",
    while: runInstall,
    ctx
  });
}
async function gitInitQuestionStep(ctx) {
  if (fs__default["default"].existsSync(path__default["default"].join(ctx.cwd, ".git"))) {
    utils.info("Nice!", `Git has already been initialized`);
    return;
  }
  let git = ctx.git;
  if (ctx.git === undefined) {
    ({
      git
    } = await ctx.prompt({
      name: "git",
      type: "confirm",
      label: title("git"),
      message: `Initialize a new git repository?`,
      hint: "recommended",
      initial: true
    }));
  }
  ctx.git = git ?? false;
}
async function gitInitStep(ctx) {
  if (!ctx.git) {
    return;
  }
  if (fs__default["default"].existsSync(path__default["default"].join(ctx.cwd, ".git"))) {
    utils.log("");
    utils.info("Nice!", `Git has already been initialized`);
    return;
  }
  utils.log("");
  await loadingIndicator({
    start: "Git initializing...",
    end: "Git initialized",
    while: async () => {
      let options = {
        cwd: ctx.cwd,
        stdio: "ignore"
      };
      let commitMsg = "Initial commit from create-remix";
      try {
        await execa__default["default"]("git", ["init"], options);
        await execa__default["default"]("git", ["add", "."], options);
        await execa__default["default"]("git", ["commit", "-m", commitMsg], options);
      } catch (err) {
        utils.error("Oh no!", "Failed to initialize git.");
        throw err;
      }
    },
    ctx
  });
}
async function runInitScriptStep(ctx) {
  if (!ctx.initScriptPath) {
    return;
  }
  let initCommand = `${packageManagerExecScript[ctx.pkgManager]} remix init`;
  if (!ctx.install || !ctx.initScript) {
    await utils.sleep(100);
    utils.log("");
    utils.info("Skipping template's remix.init script.", [ctx.install ? "You can run the script in the " : "After installing dependencies, you can run the script in the ", utils.color.reset("remix.init"), " directory with ", utils.color.reset(initCommand), "."]);
    return;
  }
  let initScriptDir = path__default["default"].dirname(ctx.initScriptPath);
  let initPackageJson = path__default["default"].resolve(initScriptDir, "package.json");
  let packageManager = ctx.pkgManager;
  try {
    if (await utils.fileExists(initPackageJson)) {
      await loadingIndicator({
        start: `Dependencies for remix.init script installing with ${ctx.pkgManager}...`,
        end: "Dependencies for remix.init script installed",
        while: () => installDependencies({
          pkgManager: ctx.pkgManager,
          cwd: initScriptDir,
          showInstallOutput: ctx.showInstallOutput
        }),
        ctx
      });
    }
  } catch (err) {
    utils.error("Oh no!", "Failed to install dependencies for template init script");
    throw err;
  }
  utils.log("");
  utils.info("Running template's remix.init script...", "\n");
  try {
    let initFn = require(ctx.initScriptPath);
    if (typeof initFn !== "function" && initFn.default) {
      initFn = initFn.default;
    }
    if (typeof initFn !== "function") {
      throw new Error("remix.init script doesn't export a function.");
    }
    let rootDirectory = path__default["default"].resolve(ctx.cwd);
    await initFn({
      packageManager,
      rootDirectory
    });
  } catch (err) {
    utils.error("Oh no!", "Template's remix.init script failed");
    throw err;
  }
  try {
    await rm__default["default"](initScriptDir);
  } catch (err) {
    utils.error("Oh no!", "Failed to remove template's remix.init script");
    throw err;
  }
  utils.log("");
  utils.success("Template's remix.init script complete");
  if (ctx.git) {
    await loadingIndicator({
      start: "Committing changes from remix.init script...",
      end: "Committed changes from remix.init script",
      while: async () => {
        let options = {
          cwd: ctx.cwd,
          stdio: "ignore"
        };
        let commitMsg = "Initialize project with remix.init script";
        try {
          await execa__default["default"]("git", ["add", "."], options);
          await execa__default["default"]("git", ["commit", "-m", commitMsg], options);
        } catch (err) {
          utils.error("Oh no!", "Failed to commit changes from remix.init script.");
          throw err;
        }
      },
      ctx
    });
  }
}
async function doneStep(ctx) {
  let projectDir = path__default["default"].relative(process__default["default"].cwd(), ctx.cwd);
  let max = process__default["default"].stdout.columns;
  let prefix = max < 80 ? " " : " ".repeat(9);
  await utils.sleep(200);
  utils.log(`\n ${utils.color.bgWhite(utils.color.black(" done "))}  That's it!`);
  await utils.sleep(100);
  if (projectDir !== "") {
    let enter = [`\n${prefix}Enter your project directory using`, utils.color.cyan(`cd .${path__default["default"].sep}${projectDir}`)];
    let len = enter[0].length + stripAnsi__default["default"](enter[1]).length;
    utils.log(enter.join(len > max ? "\n" + prefix : " "));
  }
  utils.log(`${prefix}Check out ${utils.color.bold("README.md")} for development and deploy instructions.`);
  await utils.sleep(100);
  utils.log(`\n${prefix}Join the community at ${utils.color.cyan(`https://rmx.as/discord`)}\n`);
  await utils.sleep(200);
}
const packageManagerExecScript = {
  npm: "npx",
  yarn: "yarn",
  pnpm: "pnpm exec",
  bun: "bunx"
};
function validatePackageManager(pkgManager) {
  return packageManagerExecScript.hasOwnProperty(pkgManager) ? pkgManager : "npm";
}
async function installDependencies({
  pkgManager,
  cwd,
  showInstallOutput
}) {
  try {
    await execa__default["default"](pkgManager, ["install"], {
      cwd,
      stdio: showInstallOutput ? "inherit" : "ignore"
    });
  } catch (err) {
    utils.error("Oh no!", "Failed to install dependencies.");
    throw err;
  }
}
async function updatePackageJSON(ctx) {
  let packageJSONPath = path__default["default"].join(ctx.cwd, "package.json");
  if (!fs__default["default"].existsSync(packageJSONPath)) {
    let relativePath = path__default["default"].relative(process__default["default"].cwd(), ctx.cwd);
    utils.error("Oh no!", "The provided template must be a Remix project with a `package.json` " + `file, but that file does not exist in ${utils.color.bold(relativePath)}.`);
    throw new Error(`package.json does not exist in ${ctx.cwd}`);
  }
  let contents = await fs__default["default"].promises.readFile(packageJSONPath, "utf-8");
  let packageJSON;
  try {
    packageJSON = JSON.parse(contents);
    if (!utils.isValidJsonObject(packageJSON)) {
      throw Error();
    }
  } catch (err) {
    utils.error("Oh no!", "The provided template must be a Remix project with a `package.json` " + `file, but that file is invalid.`);
    throw err;
  }
  for (let pkgKey of ["dependencies", "devDependencies"]) {
    let dependencies = packageJSON[pkgKey];
    if (!dependencies) continue;
    if (!utils.isValidJsonObject(dependencies)) {
      utils.error("Oh no!", "The provided template must be a Remix project with a `package.json` " + `file, but its ${pkgKey} value is invalid.`);
      throw new Error(`package.json ${pkgKey} are invalid`);
    }
    for (let dependency in dependencies) {
      let version = dependencies[dependency];
      if ((dependency.startsWith("@remix-run/") || dependency === "remix") && version === "*") {
        dependencies[dependency] = semver__namespace.prerelease(ctx.remixVersion) ?
        // Templates created from prereleases should pin to a specific version
        ctx.remixVersion : "^" + ctx.remixVersion;
      }
    }
  }
  if (!ctx.initScriptPath) {
    packageJSON.name = ctx.projectName;
  }
  fs__default["default"].promises.writeFile(packageJSONPath, JSON.stringify(sortPackageJSON__default["default"](packageJSON), null, 2), "utf-8");
}
async function loadingIndicator(args) {
  let {
    ctx,
    ...rest
  } = args;
  await loadingIndicator$1.renderLoadingIndicator({
    ...rest,
    noMotion: args.ctx.noMotion
  });
}
function title(text) {
  return align(utils.color.bgWhite(` ${utils.color.black(text)} `), "end", 7) + " ";
}
function printHelp(ctx) {
  // prettier-ignore
  let output = `
${title("create-remix")}

${utils.color.heading("Usage")}:

${utils.color.dim("$")} ${utils.color.greenBright("create-remix")} ${utils.color.arg("<projectDir>")} ${utils.color.arg("<...options>")}

${utils.color.heading("Values")}:

${utils.color.arg("projectDir")}          ${utils.color.dim(`The Remix project directory`)}

${utils.color.heading("Options")}:

${utils.color.arg("--help, -h")}          ${utils.color.dim(`Print this help message and exit`)}
${utils.color.arg("--version, -V")}       ${utils.color.dim(`Print the CLI version and exit`)}
${utils.color.arg("--no-color")}          ${utils.color.dim(`Disable ANSI colors in console output`)}
${utils.color.arg("--no-motion")}         ${utils.color.dim(`Disable animations in console output`)}

${utils.color.arg("--template <name>")}   ${utils.color.dim(`The project template to use`)}
${utils.color.arg("--[no-]install")}      ${utils.color.dim(`Whether or not to install dependencies after creation`)}
${utils.color.arg("--package-manager")}   ${utils.color.dim(`The package manager to use`)}
${utils.color.arg("--show-install-output")}   ${utils.color.dim(`Whether to show the output of the install process`)}
${utils.color.arg("--[no-]init-script")}  ${utils.color.dim(`Whether or not to run the template's remix.init script, if present`)}
${utils.color.arg("--[no-]git-init")}     ${utils.color.dim(`Whether or not to initialize a Git repository`)}
${utils.color.arg("--yes, -y")}           ${utils.color.dim(`Skip all option prompts and run setup`)}
${utils.color.arg("--remix-version, -v")}     ${utils.color.dim(`The version of Remix to use`)}

${utils.color.heading("Creating a new project")}:

Remix projects are created from templates. A template can be:

- a GitHub repo shorthand, :username/:repo or :username/:repo/:directory
- the URL of a GitHub repo (or directory within it)
- the URL of a tarball
- a file path to a directory of files
- a file path to a tarball
${["remix-run/grunge-stack", "remix-run/remix/templates/remix", "remix-run/examples/basic", ":username/:repo", ":username/:repo/:directory", "https://github.com/:username/:repo", "https://github.com/:username/:repo/tree/:branch", "https://github.com/:username/:repo/tree/:branch/:directory", "https://github.com/:username/:repo/archive/refs/tags/:tag.tar.gz", "https://example.com/remix-template.tar.gz", "./path/to/remix-template", "./path/to/remix-template.tar.gz"].reduce((str, example) => {
    return `${str}\n${utils.color.dim("$")} ${utils.color.greenBright("create-remix")} my-app ${utils.color.arg(`--template ${example}`)}`;
  }, "")}

To create a new project from a template in a private GitHub repo,
pass the \`token\` flag with a personal access token with access
to that repo.

${utils.color.heading("Initialize a project")}:

Remix project templates may contain a \`remix.init\` directory
with a script that initializes the project. This script automatically
runs during \`remix create\`, but if you ever need to run it manually
you can run:

${utils.color.dim("$")} ${utils.color.greenBright("remix")} init
`;
  utils.log(output);
}
function align(text, dir, len) {
  let pad = Math.max(len - utils.strip(text).length, 0);
  switch (dir) {
    case "start":
      return text + " ".repeat(pad);
    case "end":
      return " ".repeat(pad) + text;
    case "center":
      return " ".repeat(Math.floor(pad / 2)) + text + " ".repeat(Math.floor(pad / 2));
    default:
      return text;
  }
}
async function getInitScriptPath(cwd) {
  let initScriptDir = path__default["default"].join(cwd, "remix.init");
  let initScriptPath = path__default["default"].resolve(initScriptDir, "index.js");
  return (await utils.fileExists(initScriptPath)) ? initScriptPath : null;
}

exports.createRemix = createRemix;
