/// <reference types="node" />
/// <reference types="node" />
import process from "node:process";
import { type Key as ActionKey } from "node:readline";
import chalk from "chalk";
export declare const color: {
    supportsColor: boolean;
    heading: chalk.Chalk | typeof identity;
    arg: chalk.Chalk | typeof identity;
    error: chalk.Chalk | typeof identity;
    warning: chalk.Chalk | typeof identity;
    hint: chalk.Chalk | typeof identity;
    bold: chalk.Chalk | typeof identity;
    black: chalk.Chalk | typeof identity;
    white: chalk.Chalk | typeof identity;
    blue: chalk.Chalk | typeof identity;
    cyan: chalk.Chalk | typeof identity;
    red: chalk.Chalk | typeof identity;
    yellow: chalk.Chalk | typeof identity;
    green: chalk.Chalk | typeof identity;
    blackBright: chalk.Chalk | typeof identity;
    whiteBright: chalk.Chalk | typeof identity;
    blueBright: chalk.Chalk | typeof identity;
    cyanBright: chalk.Chalk | typeof identity;
    redBright: chalk.Chalk | typeof identity;
    yellowBright: chalk.Chalk | typeof identity;
    greenBright: chalk.Chalk | typeof identity;
    bgBlack: chalk.Chalk | typeof identity;
    bgWhite: chalk.Chalk | typeof identity;
    bgBlue: chalk.Chalk | typeof identity;
    bgCyan: chalk.Chalk | typeof identity;
    bgRed: chalk.Chalk | typeof identity;
    bgYellow: chalk.Chalk | typeof identity;
    bgGreen: chalk.Chalk | typeof identity;
    bgBlackBright: chalk.Chalk | typeof identity;
    bgWhiteBright: chalk.Chalk | typeof identity;
    bgBlueBright: chalk.Chalk | typeof identity;
    bgCyanBright: chalk.Chalk | typeof identity;
    bgRedBright: chalk.Chalk | typeof identity;
    bgYellowBright: chalk.Chalk | typeof identity;
    bgGreenBright: chalk.Chalk | typeof identity;
    gray: chalk.Chalk | typeof identity;
    dim: chalk.Chalk | typeof identity;
    reset: chalk.Chalk | typeof identity;
    inverse: chalk.Chalk | typeof identity;
    hex: (color: string) => chalk.Chalk | typeof identity;
    underline: chalk.Chalk;
};
export { type ActionKey };
export declare const shouldUseAscii: () => boolean;
export declare function isInteractive(): boolean;
export declare function log(message: string): boolean;
export declare let stderr: NodeJS.WriteStream & {
    fd: 2;
};
/** @internal Used to mock `process.stderr.write` for testing purposes */
export declare function setStderr(writable: typeof process.stderr): void;
export declare function logError(message: string): boolean;
export declare function debug(prefix: string, text?: string | string[]): void;
export declare function info(prefix: string, text?: string | string[]): void;
export declare function success(text: string): void;
export declare function error(prefix: string, text?: string | string[]): void;
export declare function sleep(ms: number): Promise<void>;
export declare function toValidProjectName(projectName: string): string;
export declare function identity<V>(v: V): V;
export declare function strip(str: string): string;
export declare function reverse<T>(arr: T[]): T[];
export declare function isValidJsonObject(obj: any): obj is Record<string, unknown>;
export declare function directoryExists(p: string): Promise<boolean>;
export declare function fileExists(p: string): Promise<boolean>;
export declare function ensureDirectory(dir: string): Promise<void>;
export declare function pathContains(path: string, dir: string): boolean;
export declare function isUrl(value: string | URL): boolean;
export declare function clear(prompt: string, perLine: number): string;
export declare function lines(msg: string, perLine: number): number;
export declare function action(key: ActionKey, isSelect: boolean): false | "first" | "abort" | "last" | "reset" | "down" | "up" | "submit" | "delete" | "deleteForward" | "exit" | "next" | "nextPage" | "prevPage" | "home" | "end" | "right" | "left" | undefined;
export declare function stripDirectoryFromPath(dir: string, filePath: string): string;
export declare const IGNORED_TEMPLATE_DIRECTORIES: string[];
export declare function getDirectoryFilesRecursive(dir: string): Promise<string[]>;
