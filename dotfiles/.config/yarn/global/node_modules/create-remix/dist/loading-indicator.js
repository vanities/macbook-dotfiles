/**
 * create-remix v2.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var process = require('node:process');
var readline = require('node:readline');
var sisteransi = require('sisteransi');
var utils = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var process__default = /*#__PURE__*/_interopDefaultLegacy(process);
var readline__default = /*#__PURE__*/_interopDefaultLegacy(readline);

// Adapted from https://github.com/withastro/cli-kit
const GRADIENT_COLORS = ["#ffffff", "#dadada", "#dadada", "#a8deaa", "#a8deaa", "#a8deaa", "#d0f0bd", "#d0f0bd", "#ffffed", "#ffffed", "#ffffed", "#ffffed", "#ffffed", "#ffffed", "#ffffed", "#ffffed", "#ffffed", "#f7f8ca", "#f7f8ca", "#eae6ba", "#eae6ba", "#eae6ba", "#dadada", "#dadada", "#ffffff"];
const MAX_FRAMES = 8;
const LEADING_FRAMES = Array.from({
  length: MAX_FRAMES * 2
}, () => GRADIENT_COLORS[0]);
const TRAILING_FRAMES = Array.from({
  length: MAX_FRAMES * 2
}, () => GRADIENT_COLORS[GRADIENT_COLORS.length - 1]);
const INDICATOR_FULL_FRAMES = [...LEADING_FRAMES, ...GRADIENT_COLORS, ...TRAILING_FRAMES, ...utils.reverse(GRADIENT_COLORS)];
const INDICATOR_GRADIENT = utils.reverse(INDICATOR_FULL_FRAMES.map((_, i) => loadingIndicatorFrame(i)));
async function renderLoadingIndicator({
  start,
  end,
  while: update = () => utils.sleep(100),
  noMotion = false,
  stdin = process__default["default"].stdin,
  stdout = process__default["default"].stdout
}) {
  let act = update();
  let tooSlow = Object.create(null);
  let result = await Promise.race([utils.sleep(500).then(() => tooSlow), act]);
  if (result === tooSlow) {
    let loading = await gradient(utils.color.green(start), {
      stdin,
      stdout,
      noMotion
    });
    await act;
    loading.stop();
  }
  stdout.write(`${" ".repeat(5)} ${utils.color.green("✔")}  ${utils.color.green(end)}\n`);
}
function loadingIndicatorFrame(offset = 0) {
  let frames = INDICATOR_FULL_FRAMES.slice(offset, offset + (MAX_FRAMES - 2));
  if (frames.length < MAX_FRAMES - 2) {
    let filled = new Array(MAX_FRAMES - frames.length - 2).fill(GRADIENT_COLORS[0]);
    frames.push(...filled);
  }
  return frames;
}
function getGradientAnimationFrames() {
  return INDICATOR_GRADIENT.map(colors => " " + colors.map((g, i) => utils.color.hex(g)("█")).join(""));
}
async function gradient(text, {
  stdin = process__default["default"].stdin,
  stdout = process__default["default"].stdout,
  noMotion = false
} = {}) {
  let {
    createLogUpdate
  } = await import('log-update');
  let logUpdate = createLogUpdate(stdout);
  let frameIndex = 0;
  let frames = getGradientAnimationFrames();
  let interval;
  let rl = readline__default["default"].createInterface({
    input: stdin,
    escapeCodeTimeout: 50
  });
  readline__default["default"].emitKeypressEvents(stdin, rl);
  if (stdin.isTTY) stdin.setRawMode(true);
  function keypress(char) {
    if (char === "\x03") {
      loadingIndicator.stop();
      process__default["default"].exit(0);
    }
    if (stdin.isTTY) stdin.setRawMode(true);
    stdout.write(sisteransi.cursor.hide + sisteransi.erase.lines(1));
  }
  let done = false;
  let loadingIndicator = {
    start() {
      stdout.write(sisteransi.cursor.hide);
      stdin.on("keypress", keypress);
      logUpdate(`${frames[0]}  ${text}`);
      async function loop() {
        if (done) return;
        if (frameIndex < frames.length - 1) {
          frameIndex++;
        } else {
          frameIndex = 0;
        }
        let frame = frames[frameIndex];
        logUpdate(`${(noMotion ? getMotionlessFrame() : utils.color.supportsColor ? frame : getColorlessFrame(frameIndex)).padEnd(MAX_FRAMES - 1, " ")}  ${text}`);
        if (!done) await utils.sleep(20);
        loop();
      }
      loop();
    },
    stop() {
      done = true;
      stdin.removeListener("keypress", keypress);
      clearInterval(interval);
      logUpdate.clear();
      rl.close();
    }
  };
  loadingIndicator.start();
  return loadingIndicator;
}
function getColorlessFrame(frameIndex) {
  return (frameIndex % 3 === 0 ? ".. .. " : frameIndex % 3 === 1 ? " .. .." : ". .. .").padEnd(MAX_FRAMES - 1 + 20, " ");
}
function getMotionlessFrame(frameIndex) {
  return " ".repeat(MAX_FRAMES - 1);
}

exports.renderLoadingIndicator = renderLoadingIndicator;
