/**
 * create-remix v2.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('node:path');
var process = require('node:process');
var os = require('node:os');
var fs = require('node:fs');
var sisteransi = require('sisteransi');
var chalk = require('chalk');
var recursiveReaddir = require('recursive-readdir');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var process__default = /*#__PURE__*/_interopDefaultLegacy(process);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var recursiveReaddir__default = /*#__PURE__*/_interopDefaultLegacy(recursiveReaddir);

// https://no-color.org/
const SUPPORTS_COLOR = chalk__default["default"].supportsColor && !process__default["default"].env.NO_COLOR;
const color = {
  supportsColor: SUPPORTS_COLOR,
  heading: safeColor(chalk__default["default"].bold),
  arg: safeColor(chalk__default["default"].yellowBright),
  error: safeColor(chalk__default["default"].red),
  warning: safeColor(chalk__default["default"].yellow),
  hint: safeColor(chalk__default["default"].blue),
  bold: safeColor(chalk__default["default"].bold),
  black: safeColor(chalk__default["default"].black),
  white: safeColor(chalk__default["default"].white),
  blue: safeColor(chalk__default["default"].blue),
  cyan: safeColor(chalk__default["default"].cyan),
  red: safeColor(chalk__default["default"].red),
  yellow: safeColor(chalk__default["default"].yellow),
  green: safeColor(chalk__default["default"].green),
  blackBright: safeColor(chalk__default["default"].blackBright),
  whiteBright: safeColor(chalk__default["default"].whiteBright),
  blueBright: safeColor(chalk__default["default"].blueBright),
  cyanBright: safeColor(chalk__default["default"].cyanBright),
  redBright: safeColor(chalk__default["default"].redBright),
  yellowBright: safeColor(chalk__default["default"].yellowBright),
  greenBright: safeColor(chalk__default["default"].greenBright),
  bgBlack: safeColor(chalk__default["default"].bgBlack),
  bgWhite: safeColor(chalk__default["default"].bgWhite),
  bgBlue: safeColor(chalk__default["default"].bgBlue),
  bgCyan: safeColor(chalk__default["default"].bgCyan),
  bgRed: safeColor(chalk__default["default"].bgRed),
  bgYellow: safeColor(chalk__default["default"].bgYellow),
  bgGreen: safeColor(chalk__default["default"].bgGreen),
  bgBlackBright: safeColor(chalk__default["default"].bgBlackBright),
  bgWhiteBright: safeColor(chalk__default["default"].bgWhiteBright),
  bgBlueBright: safeColor(chalk__default["default"].bgBlueBright),
  bgCyanBright: safeColor(chalk__default["default"].bgCyanBright),
  bgRedBright: safeColor(chalk__default["default"].bgRedBright),
  bgYellowBright: safeColor(chalk__default["default"].bgYellowBright),
  bgGreenBright: safeColor(chalk__default["default"].bgGreenBright),
  gray: safeColor(chalk__default["default"].gray),
  dim: safeColor(chalk__default["default"].dim),
  reset: safeColor(chalk__default["default"].reset),
  inverse: safeColor(chalk__default["default"].inverse),
  hex: color => safeColor(chalk__default["default"].hex(color)),
  underline: chalk__default["default"].underline
};
function safeColor(style) {
  return SUPPORTS_COLOR ? style : identity;
}
const unicode = {
  enabled: os__default["default"].platform() !== "win32"
};
const shouldUseAscii = () => !unicode.enabled;
function isInteractive() {
  // Support explicit override for testing purposes
  if ("CREATE_REMIX_FORCE_INTERACTIVE" in process__default["default"].env) {
    return true;
  }

  // Adapted from https://github.com/sindresorhus/is-interactive
  return Boolean(process__default["default"].stdout.isTTY && process__default["default"].env.TERM !== "dumb" && !("CI" in process__default["default"].env));
}
function log(message) {
  return process__default["default"].stdout.write(message + "\n");
}
let stderr = process__default["default"].stderr;
function logError(message) {
  return stderr.write(message + "\n");
}
function logBullet(logger, colorizePrefix, colorizeText, symbol, prefix, text) {
  let textParts = Array.isArray(text) ? text : [text || ""].filter(Boolean);
  let formattedText = textParts.map(textPart => colorizeText(textPart)).join("");
  if (process__default["default"].stdout.columns < 80) {
    logger(`${" ".repeat(5)} ${colorizePrefix(symbol)}  ${colorizePrefix(prefix)}`);
    logger(`${" ".repeat(9)}${formattedText}`);
  } else {
    logger(`${" ".repeat(5)} ${colorizePrefix(symbol)}  ${colorizePrefix(prefix)} ${formattedText}`);
  }
}
function debug(prefix, text) {
  logBullet(log, color.yellow, color.dim, "●", prefix, text);
}
function info(prefix, text) {
  logBullet(log, color.cyan, color.dim, "◼", prefix, text);
}
function success(text) {
  logBullet(log, color.green, color.dim, "✔", text);
}
function error(prefix, text) {
  log("");
  logBullet(logError, color.red, color.error, "▲", prefix, text);
}
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
function toValidProjectName(projectName) {
  if (isValidProjectName(projectName)) {
    return projectName;
  }
  return projectName.trim().toLowerCase().replace(/\s+/g, "-").replace(/^[._]/, "").replace(/[^a-z\d\-~]+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
}
function isValidProjectName(projectName) {
  return /^(?:@[a-z\d\-*~][a-z\d\-*._~]*\/)?[a-z\d\-~][a-z\d\-._~]*$/.test(projectName);
}
function identity(v) {
  return v;
}
function strip(str) {
  let pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|");
  let RGX = new RegExp(pattern, "g");
  return typeof str === "string" ? str.replace(RGX, "") : str;
}
function reverse(arr) {
  return [...arr].reverse();
}
function isValidJsonObject(obj) {
  return !!(obj && typeof obj === "object" && !Array.isArray(obj));
}
async function directoryExists(p) {
  try {
    let stat = await fs__default["default"].promises.stat(p);
    return stat.isDirectory();
  } catch {
    return false;
  }
}
async function fileExists(p) {
  try {
    let stat = await fs__default["default"].promises.stat(p);
    return stat.isFile();
  } catch {
    return false;
  }
}
async function ensureDirectory(dir) {
  if (!(await directoryExists(dir))) {
    await fs__default["default"].promises.mkdir(dir, {
      recursive: true
    });
  }
}
function isUrl(value) {
  try {
    new URL(value);
    return true;
  } catch (_) {
    return false;
  }
}
function clear(prompt, perLine) {
  if (!perLine) return sisteransi.erase.line + sisteransi.cursor.to(0);
  let rows = 0;
  let lines = prompt.split(/\r?\n/);
  for (let line of lines) {
    rows += 1 + Math.floor(Math.max(strip(line).length - 1, 0) / perLine);
  }
  return sisteransi.erase.lines(rows);
}
function lines(msg, perLine) {
  let lines = String(strip(msg) || "").split(/\r?\n/);
  if (!perLine) return lines.length;
  return lines.map(l => Math.ceil(l.length / perLine)).reduce((a, b) => a + b);
}
function action(key, isSelect) {
  if (key.meta && key.name !== "escape") return;
  if (key.ctrl) {
    if (key.name === "a") return "first";
    if (key.name === "c") return "abort";
    if (key.name === "d") return "abort";
    if (key.name === "e") return "last";
    if (key.name === "g") return "reset";
  }
  if (isSelect) {
    if (key.name === "j") return "down";
    if (key.name === "k") return "up";
  }
  if (key.name === "return") return "submit";
  if (key.name === "enter") return "submit"; // ctrl + J
  if (key.name === "backspace") return "delete";
  if (key.name === "delete") return "deleteForward";
  if (key.name === "abort") return "abort";
  if (key.name === "escape") return "exit";
  if (key.name === "tab") return "next";
  if (key.name === "pagedown") return "nextPage";
  if (key.name === "pageup") return "prevPage";
  if (key.name === "home") return "home";
  if (key.name === "end") return "end";
  if (key.name === "up") return "up";
  if (key.name === "down") return "down";
  if (key.name === "right") return "right";
  if (key.name === "left") return "left";
  return false;
}
function stripDirectoryFromPath(dir, filePath) {
  // Can't just do a regexp replace here since the windows paths mess it up :/
  let stripped = filePath;
  if (dir.endsWith(path__default["default"].sep) && filePath.startsWith(dir) || !dir.endsWith(path__default["default"].sep) && filePath.startsWith(dir + path__default["default"].sep)) {
    stripped = filePath.slice(dir.length);
    if (stripped.startsWith(path__default["default"].sep)) {
      stripped = stripped.slice(1);
    }
  }
  return stripped;
}

// We do not copy these folders from templates so we can ignore them for comparisons
const IGNORED_TEMPLATE_DIRECTORIES = [".git", "node_modules"];
async function getDirectoryFilesRecursive(dir) {
  let files = await recursiveReaddir__default["default"](dir, [file => {
    let strippedFile = stripDirectoryFromPath(dir, file);
    let parts = strippedFile.split(path__default["default"].sep);
    return parts.length > 1 && IGNORED_TEMPLATE_DIRECTORIES.includes(parts[0]);
  }]);
  return files.map(f => stripDirectoryFromPath(dir, f));
}

exports.IGNORED_TEMPLATE_DIRECTORIES = IGNORED_TEMPLATE_DIRECTORIES;
exports.action = action;
exports.clear = clear;
exports.color = color;
exports.debug = debug;
exports.directoryExists = directoryExists;
exports.ensureDirectory = ensureDirectory;
exports.error = error;
exports.fileExists = fileExists;
exports.getDirectoryFilesRecursive = getDirectoryFilesRecursive;
exports.identity = identity;
exports.info = info;
exports.isInteractive = isInteractive;
exports.isUrl = isUrl;
exports.isValidJsonObject = isValidJsonObject;
exports.lines = lines;
exports.log = log;
exports.logError = logError;
exports.reverse = reverse;
exports.shouldUseAscii = shouldUseAscii;
exports.sleep = sleep;
exports.stderr = stderr;
exports.strip = strip;
exports.stripDirectoryFromPath = stripDirectoryFromPath;
exports.success = success;
exports.toValidProjectName = toValidProjectName;
